From 2d89bcc27a5941580a4e845133187fa88f7dff93 Mon Sep 17 00:00:00 2001
From: Leo Wang <leowang@nexcom.com.tw>
Date: Wed, 12 Mar 2025 15:19:03 +0800
Subject: [PATCH] ksz9477: for nexcom atc3750-6c customized build.

---
 drivers/net/dsa/microchip/ksz9477.c     | 549 +++++++++++++++++++++++-
 drivers/net/dsa/microchip/ksz9477_reg.h |   9 +
 drivers/net/dsa/microchip/ksz9477_spi.c |   3 +-
 drivers/net/dsa/microchip/ksz_common.h  |   4 +
 4 files changed, 560 insertions(+), 5 deletions(-)

diff --git a/drivers/net/dsa/microchip/ksz9477.c b/drivers/net/dsa/microchip/ksz9477.c
index bf788e17f408..f84402c6d419 100644
--- a/drivers/net/dsa/microchip/ksz9477.c
+++ b/drivers/net/dsa/microchip/ksz9477.c
@@ -22,6 +22,8 @@
 #define NEW_XMII			BIT(1)
 #define IS_9893				BIT(2)
 
+static void ksz9477_monitor_sgmii_an(struct work_struct *work);
+
 static const struct {
 	int index;
 	char string[ETH_GSTRING_LEN];
@@ -197,7 +199,7 @@ static int ksz9477_reset_switch(struct ksz_device *dev)
 {
 	u8 data8;
 	u32 data32;
-
+	return 0;
 	/* reset switch */
 	ksz_cfg(dev, REG_SW_OPERATION, SW_RESET, true);
 
@@ -1113,6 +1115,16 @@ static phy_interface_t ksz9477_get_interface(struct ksz_device *dev, int port)
 	return interface;
 }
 
+static void ksz9477_port_mmd_read(struct ksz_device *dev, int port,
+				   u8 dev_addr, u16 reg_addr, u16 *val)
+{
+	ksz_pwrite16(dev, port, REG_PORT_PHY_MMD_SETUP,
+		     MMD_SETUP(PORT_MMD_OP_INDEX, dev_addr));
+	ksz_pwrite16(dev, port, REG_PORT_PHY_MMD_INDEX_DATA, reg_addr);
+	ksz_pwrite16(dev, port, REG_PORT_PHY_MMD_SETUP, 0x8000 | dev_addr);
+	ksz_pread16(dev, port, REG_PORT_PHY_MMD_INDEX_DATA, val);
+}
+
 static void ksz9477_port_mmd_write(struct ksz_device *dev, int port,
 				   u8 dev_addr, u16 reg_addr, u16 val)
 {
@@ -1537,6 +1549,533 @@ static const struct ksz_chip_data ksz9477_switch_chips[] = {
 	},
 };
 
+static void ksz9477_eee_disable(struct ksz_device *dev) {
+	int i = 0;
+	u16 data16=0;
+	for (i=0; i<5; i++) {
+		//ksz9477_port_mmd_read(dev, i, 0x7, 0x3C, &data16);
+		//printk("[ksz9477_rgmii_init] MMD EEE(Enable/Disable) (0x07, 0x3C)=0x%02X \n", data16);
+		ksz9477_port_mmd_write(dev, i, 0x7, 0x3C, 0x0);
+
+		ksz9477_port_mmd_read(dev, i, 0x7, 0x3C, &data16);
+		printk("[ksz9477_rgmii_init] MMD EEE(Enable/Disable) (0x07, 0x3C)=0x%02X \n", data16);
+	}	
+}
+static void ksz9477_jumbo_frame_init(struct ksz_device *dev) {
+	u8 read_addr_data = 0;
+	u16 read_mtu_data = 0;
+	u16 mtu_max_size = 0x2328;
+	//printk("[ksz9477] ksz9477_ENABLE_JUMBO_FRAME\n");	
+	ksz_cfg(dev, REG_SW_MAC_CTRL_1, SW_JUMBO_PACKET, true);
+	/* accept packet up to 2000bytes */
+    	ksz_cfg(dev, REG_SW_MAC_CTRL_1, SW_LEGAL_PACKET_DISABLE, true);	
+        
+	ksz_read8(dev, REG_SW_MAC_CTRL_1 , &read_addr_data);
+	printk("[ksz9477] ksz9477_ENABLE_JUMBO_FRAME [0x%X]=0x%X\n", REG_SW_MAC_CTRL_1, read_addr_data);	
+
+	//printk("[ksz9477] ksz9477 setting max mtu sizes.\n");
+	ksz_write16(dev, REG_SW_MTU__2, mtu_max_size);
+	ksz_read16(dev,REG_SW_MTU__2,&read_mtu_data);
+	printk("[ksz9477] ksz9477_READ MTU MAX SIZES [0x%X]=0x%X\n", REG_SW_MTU__2, read_mtu_data);	
+	
+	/* port 1 jumbo packet enable */
+	ksz_cfg(dev,SWITCH_PORT1,PORTN_JUMBO_PACKET,true);
+	//ksz_read8(dev,SWITCH_PORT1,&read_addr_data);
+	//printk("[ksz9477] ksz9477 lan switch 1  [0x%X]=0x%X\n", SWITCH_PORT1, read_addr_data);
+	
+	/* port 2 jumbo packet enable */
+	ksz_cfg(dev,SWITCH_PORT2,PORTN_JUMBO_PACKET,true);
+	
+	/* port 3 jumbo packet enable */
+	ksz_cfg(dev,SWITCH_PORT3,PORTN_JUMBO_PACKET,true);
+	
+	/* port 4 jumbo packet enable */
+	ksz_cfg(dev,SWITCH_PORT4,PORTN_JUMBO_PACKET,true);
+
+	/* port 5 jumbo packet enable */
+	ksz_cfg(dev,SWITCH_PORT5,PORTN_JUMBO_PACKET,true);
+
+	/* port 6 jumbo packet enable */
+	ksz_cfg(dev,SWITCH_PORT6,PORTN_JUMBO_PACKET,true);
+}
+
+static int ksz9477_sgmii_read(struct ksz_device *dev, u32 regAddrValue, u16 *regDataValue)
+{
+       	u32 regAddrAddr=0x7200;
+       	u32 regAddrData=0x7206;
+       	u16 regReadValue=0;
+
+       	ksz_write32(dev, regAddrAddr, regAddrValue);
+       	ksz_read16(dev, regAddrData, &regReadValue);
+       //printk("[ksz9477] ksz9477_sgmii_read [0x%X]=0x%X\n", regAddrValue, regReadValue);
+       //regDataValue=&regReadValue;
+	memcpy(regDataValue, &regReadValue, sizeof(regReadValue));
+       	return 1;
+}
+
+static int ksz9477_sgmii_write(struct ksz_device *dev, u32 regAddrValue, u16 regDataValue)
+{
+       //printk("[ksz9477] ksz9477_sgmii_write for SGMII [0x%X]/[0x%X]... \n", regAddrValue, regDataValue);
+       u32 regAddrAddr=0x7200;
+       u32 regAddrData=0x7206;
+       //u16 regReadValue=0;
+
+       //ksz9477_sgmii_read(dev, regAddrValue, &regReadValue);
+
+       ksz_write32(dev, regAddrAddr, regAddrValue);
+       ksz_write16(dev, regAddrData, regDataValue);
+
+       //ksz9477_sgmii_read(dev, regAddrValue, &regReadValue);
+       usleep_range(1000, 2000);
+
+       return 1;
+}
+
+static void ksz9477_initsgmii(struct ksz_device *dev) {
+	u32 regAddrValue=0;
+	u16 regDataValue=0;
+	
+	printk("[ksz9477] initial for SGMII ... \n");
+	regAddrValue=0x1F0000;
+	regDataValue=0x9140; //1000M
+	//regDataValue=0xA100; //100M
+	//Reset Switch SGMII port
+	ksz9477_sgmii_write(dev, regAddrValue, regDataValue);
+	usleep_range(1000, 2000);
+	
+	//Read SGMII default status and control value 
+	regAddrValue=0x1F0001;
+	regDataValue=0;
+	ksz9477_sgmii_read(dev, regAddrValue, &regDataValue);
+	printk("[ksz9477_initsgmii] SGMII status (0x%X)=0x%X \n", regAddrValue, regDataValue);
+	regAddrValue=0x1F0002;
+	ksz9477_sgmii_read(dev, regAddrValue, &regDataValue);
+	printk("[ksz9477_initsgmii] SGMII status (0x%X)=0x%X \n", regAddrValue, regDataValue);
+	regAddrValue=0x1F0003;
+	ksz9477_sgmii_read(dev, regAddrValue, &regDataValue);
+	printk("[ksz9477_initsgmii] SGMII status (0x%X)=0x%X \n", regAddrValue, regDataValue);
+	
+	regAddrValue=0x1F8002;
+	ksz9477_sgmii_read(dev, regAddrValue, &regDataValue);
+	printk("[ksz9477_initsgmii] SGMII status (0x%X)=0x%X \n", regAddrValue, regDataValue);
+
+	//Configure SGMII port to MAC side and disable auto negotiation
+	regAddrValue=0x1F8001;
+	//regDataValue=0x14;
+	regDataValue=0x04; //disable auto negotiation
+	//regDataValue=0x05; //enable auto negotiation
+	ksz9477_sgmii_write(dev, regAddrValue, regDataValue);
+	
+	//Configure SGMII port to Full Duplex
+	regAddrValue=0x1F0004;
+	regDataValue=0x0020;
+	//regDataValue=0x01A0;
+	ksz9477_sgmii_write(dev, regAddrValue, regDataValue);
+	
+	//disable auto negotiation/Full Duplex/1000<bps
+	regAddrValue=0x1F0000;
+	regDataValue=0x1140; //1000M
+	//regDataValue=0x2100; //100M
+	ksz9477_sgmii_write(dev, regAddrValue, regDataValue);
+	
+	//Read SGMII status
+	regAddrValue=0x1F0001;
+	regDataValue=0;
+	ksz9477_sgmii_read(dev, regAddrValue, &regDataValue);
+	printk("[ksz9477_initsgmii] SGMII status (0x%X)=0x%X \n", regAddrValue, regDataValue);
+
+	regAddrValue=0x1F8002;
+	ksz9477_sgmii_read(dev, regAddrValue, &regDataValue);
+	printk("[ksz9477_initsgmii] SGMII status (0x%X)=0x%X \n", regAddrValue, regDataValue);
+
+	usleep_range(1000, 2000);
+	//Show SGMII refernece register in switch
+	/* 
+	ksz9477_show_reg8(dev, 0x300);
+	ksz9477_show_reg8(dev, 0x701B);
+	ksz9477_show_reg8(dev, 0x7030);
+	ksz9477_show_reg8(dev, 0x7300);
+	ksz9477_show_reg8(dev, 0x7401);
+	*/
+}
+
+static void ksz9477_set_sgmii_link(struct ksz_device *dev) {
+	u32 regAddrValue=0;
+	u16 regDataValue=0;
+	
+	u8 link_status=0;
+	u8 link_duplex=0;
+	u8 link_speed=0;
+	u8 last_link_duplex=0;
+	u8 last_link_speed=0;
+	
+	char str_speed[100];
+	
+	if (!dev) printk("[ksz9477_set_sgmii_link] dev is null \n");
+
+	regAddrValue=0x1F0000;
+	ksz9477_sgmii_read(dev, regAddrValue, &regDataValue);
+	
+	if (regDataValue & 0x100) last_link_duplex=1;
+	last_link_speed=(regDataValue&0x40) >> 5;
+	last_link_speed |=(regDataValue&0x2000) >> 13;
+	//printk("[ksz9477_set_sgmii_link] SGMII Register (0x%X)=0x%X, last_link_duplex=%d, last_link_speed=%d \n", regAddrValue, regDataValue, last_link_duplex, last_link_speed);
+	
+#if 0
+	regDataValue|=0x200;
+	regAddrValue=0x1F0000;
+	ksz9477_sgmii_write(dev, regAddrValue, &regDataValue);
+#endif
+	regAddrValue=0x1F8002;
+	ksz9477_sgmii_read(dev, regAddrValue, &regDataValue);
+	//printk("[ksz9477_set_sgmii_link] SGMII Register (0x%X)=0x%X \n", regAddrValue, regDataValue);
+	if (regDataValue & 0x10) link_status=1;
+	if (regDataValue & 0x02) link_duplex=1;
+	link_speed = (regDataValue & 0xF) >> 2;  //0: 10Mbps, 1: 100Mbps, 2:1000Mbps
+	//printk("[ksz9477_set_sgmii_link] SGMII Link Status=%d, Duplex=%d, Speed=%d \n", link_status, link_duplex, link_speed);
+	
+	regAddrValue=0x1F0000;
+	if ((link_status) && ((last_link_duplex!=link_duplex)||(last_link_speed!=link_speed)))  {
+		memset(str_speed, 0, sizeof(str_speed));
+		if (link_speed==0) {
+			regDataValue=0x0000; //10M
+			sprintf(str_speed, "%s", "10Mbps");
+		} else if (link_speed==1) {
+			regDataValue=0x2000; //100M
+			sprintf(str_speed, "%s", "100Mbps");
+		} else {
+			regDataValue=0x0040; //1000M
+			sprintf(str_speed, "%s", "1000Mbps");
+		}
+		//Enabled Auto Negotiation
+		regDataValue|=0x1000;
+		if (link_duplex==1) regDataValue|=0x0100;
+		
+		ksz9477_sgmii_write(dev, regAddrValue, regDataValue);
+		printk("[ksz9477_set_sgmii_link] Change SGMII Port[7] Speed to %s .\n", str_speed);
+
+		regAddrValue=0x1F8002;
+		ksz9477_sgmii_read(dev, regAddrValue, &regDataValue);
+		//printk("[ksz9477_set_sgmii_link] SGMII Register (0x%X)=0x%X \n", regAddrValue, regDataValue);
+		
+		last_link_duplex=link_duplex;
+		last_link_speed=link_speed;
+	}
+}
+
+static void ksz9477_monitor_sgmii_an(struct work_struct *work)
+{
+	struct ksz_device *dev = container_of(work, struct ksz_device, sgmii_an.work);
+	//printk("[ksz9477_monitor_sgmii_an] Go ... \n");
+	
+	ksz9477_set_sgmii_link(dev);
+	//1 second read one time
+	if (! &dev->sgmii_an) printk("[ksz9477_monitor_sgmii_an] dev->sgmii_an is null \n");
+	else schedule_delayed_work(&dev->sgmii_an, msecs_to_jiffies(1000));
+}
+
+static void ksz9477_normal_init(struct ksz_device *dev) {
+       //int port  = 5;
+       //u8 data8;
+       //Setup CPU Port
+	int i=0;
+	printk("[KSZ9477] ksz9477_normal_init go ... \n");
+	
+	for (i=0; i<7; i++) {
+		if (i==5) {
+			ksz9477_port_setup(dev, i, true);
+		} else {
+			ksz9477_port_setup(dev, i, false);
+		}
+	}
+	
+#if 0	
+	/* enable tag tail for host port */
+	ksz_port_cfg(dev, port, REG_PORT_CTRL_0, PORT_TAIL_TAG_ENABLE,
+			     true);
+
+	ksz_port_cfg(dev, port, REG_PORT_CTRL_0, PORT_MAC_LOOPBACK, false);
+
+	/* set back pressure */
+	ksz_port_cfg(dev, port, REG_PORT_MAC_CTRL_1, PORT_BACK_PRESSURE, true);
+
+	/* enable broadcast storm limit */
+	ksz_port_cfg(dev, port, P_BCAST_STORM_CTRL, PORT_BROADCAST_STORM, true);
+
+	/* disable DiffServ priority */
+	ksz_port_cfg(dev, port, P_PRIO_CTRL, PORT_DIFFSERV_PRIO_ENABLE, false);
+
+	/* replace priority */
+	ksz_port_cfg(dev, port, REG_PORT_MRI_MAC_CTRL, PORT_USER_PRIO_CEILING,
+		     false);
+	ksz9477_port_cfg32(dev, port, REG_PORT_MTI_QUEUE_CTRL_0__4,
+			   MTI_PVID_REPLACE, false);
+
+	/* enable 802.1p priority */
+	ksz_port_cfg(dev, port, P_PRIO_CTRL, PORT_802_1P_PRIO_ENABLE, true);
+
+	/* force flow control */
+	ksz_port_cfg(dev, port, REG_PORT_CTRL_0,
+		     PORT_FORCE_TX_FLOW_CTRL | PORT_FORCE_RX_FLOW_CTRL,
+		     true);
+
+	/* configure MAC to 1G & RGMII mode */
+	ksz_pread8(dev, port, REG_PORT_XMII_CTRL_1, &data8);
+	printk("[KSZ9477] ksz9477_normal_init[%d] REG_PORT_XMII_CTRL_1 data8=0x%X\n", port, data8);
+	
+	ksz9477_set_xmii(dev, 3, &data8);
+	ksz9477_set_gbit(dev, true, &data8);
+	data8 &= ~PORT_RGMII_ID_IG_ENABLE;
+	data8 &= ~PORT_RGMII_ID_EG_ENABLE;
+	data8 |= PORT_RGMII_ID_EG_ENABLE;
+	
+	printk("[KSZ9477] ksz9477_normal_init[%d] REG_PORT_XMII_CTRL_1 data8=0x%X\n", port, data8);
+	ksz_pwrite8(dev, port, REG_PORT_XMII_CTRL_1, data8);
+#endif
+	/* clear pending interrupts */
+	//if (port < dev->phy_port_cnt)
+	//	ksz_pread16(dev, port, REG_PORT_PHY_INT_ENABLE, &data16);
+}
+
+static void ksz9477_showinfo(struct ksz_device *dev) {
+       int i=0;
+       u8 data8=0;
+       u16 data16=0;
+       u32 data32=0;
+       u16 setreg=0;
+
+	printk("--------------------------------------------------------------------\n");
+	ksz_read8(dev, REG_CHIP_ID3__1, &data8);
+	printk("[ksz9477_showinfo] REG_CHIP_ID3__1 data8=0x%X\n", data8);
+	ksz_read8(dev, REG_SW_POWER_MANAGEMENT_CTRL, &data8);
+	printk("[ksz9477_showinfo] REG_SW_POWER_MANAGEMENT_CTRL(0x201)=0x%X \n", data8);
+	setreg=0x0100;
+	ksz_read8(dev, setreg, &data8);
+	printk("[ksz9477_showinfo] Serial I/O Control Register 0x%04X=0x%X \n", setreg, data8);
+	setreg=0x0103;
+	ksz_read8(dev, setreg, &data8);
+	printk("[ksz9477_showinfo] Output Clock Control Register 0x%04X=0x%X \n", setreg, data8);
+	setreg=0x0104;
+	ksz_read32(dev, setreg, &data32);
+	printk("[ksz9477_showinfo] In-Band Management (IBA) Control Register 0x%04X=0x%X \n", setreg, data32);
+	setreg=0x0110;
+	ksz_read32(dev, setreg, &data32);
+	printk("[ksz9477_showinfo] In-Band Management (IBA) Operation Status 0x%04X=0x%X \n", setreg, data32);
+	setreg=0x0120;
+
+	//For LED status
+	ksz_read32(dev, setreg, &data32);
+	printk("[ksz9477_showinfo] LED Override Register 0x%04X=0x%X \n", setreg, data32);
+	setreg=0x0124;
+	ksz_read32(dev, setreg, &data32);
+	printk("[ksz9477_showinfo] LED Output Register 0x%04X=0x%X \n", setreg, data32);
+	setreg=0x0210;
+	ksz_read32(dev, setreg, &data32);
+	printk("[ksz9477_showinfo] LED Configuration Strap Register 0x%04X=0x%X \n", setreg, data32);
+	
+	setreg=REG_SW_POWER_MANAGEMENT_CTRL;
+	ksz_read8(dev, setreg, &data8);
+	printk("[ksz9477_showinfo] Power Down Control 0 Register 0x%04X=0x%X \n", setreg, data8);
+	
+	//Port 6 RGMII Setting
+	ksz_pread8(dev, 5, REG_PORT_XMII_CTRL_0, &data8);
+	printk("[ksz9477_showinfo] Port 6 REG_PORT_XMII_CTRL_0(0x300)=0x%X \n", data8);
+	ksz_pread8(dev, 5, REG_PORT_XMII_CTRL_1, &data8);
+	printk("[ksz9477_showinfo] Port 6 REG_PORT_XMII_CTRL_1(0x301)=0x%X \n", data8);
+	//Port 6 RGMII Setting
+	ksz_pread8(dev, 6, REG_PORT_XMII_CTRL_0, &data8);
+	printk("[ksz9477_showinfo] Port 7 REG_PORT_XMII_CTRL_0(0x300)=0x%X \n", data8);
+	ksz_pread8(dev, 6, REG_PORT_XMII_CTRL_1, &data8);
+	printk("[ksz9477_showinfo] Port 7 REG_PORT_XMII_CTRL_1(0x301)=0x%X \n", data8);
+	printk("--------------------------------------------------------------------\n");
+
+	for (i=0; i<5; i++) {
+		printk("[ksz9477_showinfo] Port %d ----------- \n", i+1);
+		ksz_pread16(dev, i, REG_PORT_PHY_CTRL, &data16);
+		printk("[ksz9477_showinfo] REG_PORT_PHY_CTRL(0xN100)=0x%04X \n", data16);
+		ksz_pread16(dev, i, REG_PORT_PHY_CTRL, &data16);
+		printk("[ksz9477_showinfo] REG_PORT_PHY_CTRL(0xN100)=0x%04X \n", data16);
+		ksz_pread16(dev, i, REG_PORT_PHY_STATUS, &data16);
+		printk("[ksz9477_showinfo] REG_PORT_PHY_STATUS(0xN102)=0x%04X \n", data16);
+		ksz_pread16(dev, i, REG_PORT_PHY_AUTO_NEGOTIATION, &data16);
+		printk("[ksz9477_showinfo] REG_PORT_PHY_AUTO_NEGOTIATION(0xN108)=0x%04X \n", data16);
+		ksz_pread16(dev, i, REG_PORT_PHY_1000_CTRL, &data16);
+		printk("[ksz9477_showinfo] REG_PORT_PHY_1000_CTRL(0xN114)=0x%04X \n", data16);
+
+		ksz_pread16(dev, i, REG_PORT_PHY_1000_STATUS, &data16);
+		printk("[ksz9477_showinfo] PHY 1000BASE-T Status Register(0xN%X)=0x%04X \n", REG_PORT_PHY_1000_STATUS, data16);
+		ksz_pread16(dev, i, REG_PORT_PHY_MMD_SETUP, &data16);
+		printk("[ksz9477_showinfo] PHY MMD Setup Register(0xN%X)=0x%04X \n", REG_PORT_PHY_MMD_SETUP, data16);
+		ksz_pread16(dev, i, REG_PORT_PHY_MMD_INDEX_DATA, &data16);
+		printk("[ksz9477_showinfo] PHY MMD Data Register(0xN%X)=0x%04X \n", REG_PORT_PHY_MMD_INDEX_DATA, data16);
+		ksz_pread16(dev, i, REG_PORT_PHY_EXTENDED_STATUS, &data16);
+		printk("[ksz9477_showinfo] PHY Extended Status Register(0xN%X)=0x%04X \n", REG_PORT_PHY_EXTENDED_STATUS, data16);
+
+		ksz_pread16(dev, i, REG_PORT_PHY_DIGITAL_DEBUG_1, &data16);
+		printk("[ksz9477_showinfo] REG_PORT_PHY_DIGITAL_DEBUG_1(0xN138)=0x%04X \n", data16);
+
+		ksz_pread16(dev, i, REG_PORT_PHY_PHY_CTRL, &data16);
+		printk("[ksz9477_showinfo] REG_PORT_PHY_PHY_CTRL(0xN138)=0x%04X \n", data16);
+
+		ksz9477_port_mmd_read(dev, i, 0x2, 0x0, &data16);
+		printk("[ksz9477_showinfo] MMD LEDs Mode(Single/TriColor) (0x2, 0x0)=0x%04X \n", data16);
+
+		ksz9477_port_mmd_read(dev, i, 0x7, 0x3C, &data16);
+		printk("[ksz9477_showinfo] MMD LED mode status (0x7, 0x3C)=0x%04X \n", data16);
+	}
+	printk("--------------------------------------------------------------------\n");
+	for (i=0; i<7; i++) {
+		ksz_pread32(dev, i, 0x504, &data32);
+		printk("[KSZ9477] ksz9477_showinfo [Port %d]Port MIB Data (0xN504)=0x%04X \n", i+1, data32);
+	}
+	printk("--------------------------------------------------------------------\n");
+}
+
+static void ksz9477_rgmii_init(struct ksz_device *dev) {
+	u8 data8=0;
+	u16 data16=0;
+	//u32 data32=0;
+	//u16 rgmii_phy=0;
+	int i=0;
+	
+	//ksz9477_port_setup(dev, 5, true);
+	data8=1;
+#if 1
+	ksz_write8(dev, REG_CHIP_ID3__1, 1);
+	ksz_read8(dev, REG_CHIP_ID3__1, &data8);
+	usleep_range(10000, 100000);
+	ksz_read8(dev, REG_CHIP_ID3__1, &data8);
+	ksz_write8(dev, REG_CHIP_ID3__1, 0);
+	ksz_read8(dev, REG_CHIP_ID3__1, &data8);
+	usleep_range(10000, 100000);
+#endif	
+
+#if 1
+	ksz_read8(dev, REG_SW_MAC_CTRL_4, &data8);
+	//printk("[KSZ9477] 92 ksz9477_rgmii_init REG_SW_MAC_CTRL_4 data8=0x%X\n", data8);
+	ksz_write8(dev, REG_SW_MAC_CTRL_4, 0x38);
+	ksz_read8(dev, REG_SW_MAC_CTRL_4, &data8);
+	//printk("[KSZ9477] 93 ksz9477_rgmii_init REG_SW_MAC_CTRL_4 data8=0x%X\n", data8);
+#endif	
+	
+#if 1
+	ksz_pread8(dev, 5, REG_PORT_XMII_CTRL_0, &data8);
+	//printk("[KSZ9477] ksz9477_rgmii_init REG_PORT_XMII_CTRL_0(0x300)=0x%X \n", data8);
+	
+	data8=0x78;
+	ksz_pwrite8(dev, 5, REG_PORT_XMII_CTRL_0, data8);
+	
+	ksz_pread8(dev, 5, REG_PORT_XMII_CTRL_0, &data8);
+	//printk("[KSZ9477] 2 ksz9477_rgmii_init REG_PORT_XMII_CTRL_0(0x300)=0x%X \n", data8);
+#endif
+#if 0
+	ksz_pread8(dev, 5, REG_PORT_XMII_CTRL_1, &data8);
+	//printk("[KSZ9477] 1 ksz9477_rgmii_init REG_PORT_XMII_CTRL_1(0x301)=0x%X \n", data8);
+
+	//data8=0x10; //Ingress Internal Delay
+	//data8=0x08; //Engress Internal Delay
+	data8=0x18;
+	ksz_pwrite8(dev, 5, REG_PORT_XMII_CTRL_1, data8);
+	ksz_pread8(dev, 5, REG_PORT_XMII_CTRL_1, &data8);
+	//printk("[KSZ9477] 2 ksz9477_rgmii_init REG_PORT_XMII_CTRL_1(0x301)=0x%X \n", data8);
+#endif
+
+#if 1
+	ksz_pread8(dev, 6, REG_PORT_XMII_CTRL_1, &data8);
+	//printk("[KSZ9477] A ksz9477_rgmii_init[%d] REG_PORT_XMII_CTRL_1 data8=0x%X\n", 6, data8);
+	ksz_pread8(dev, 5, REG_PORT_XMII_CTRL_1, &data8);
+	//printk("[KSZ9477] A ksz9477_rgmii_init[%d] REG_PORT_XMII_CTRL_1 data8=0x%X\n", 5, data8);
+	
+	/* configure MAC to 1G & RGMII mode */
+#if 1	
+	ksz9477_set_xmii(dev, 3, &data8);
+	ksz9477_set_gbit(dev, true, &data8);
+#else
+	ksz9477_set_xmii(dev, 0, &data8);
+	ksz9477_set_gbit(dev, false, &data8);
+#endif
+	//data8 &= ~PORT_RGMII_ID_IG_ENABLE;
+	//data8 &= ~PORT_RGMII_ID_EG_ENABLE;
+#if 1	
+	data8 |= PORT_RGMII_ID_IG_ENABLE;
+	data8 |= PORT_RGMII_ID_EG_ENABLE;
+	//data8 &= ~PORT_RGMII_ID_EG_ENABLE;
+#else
+	data8 &= ~PORT_RGMII_ID_IG_ENABLE;
+	data8 &= ~PORT_RGMII_ID_EG_ENABLE;
+#endif
+
+	//printk("[KSZ9477] B ksz9477_rgmii_init[%d] REG_PORT_XMII_CTRL_1 data8=0x%X\n", 5, data8);
+	ksz_pwrite8(dev, 5, REG_PORT_XMII_CTRL_1, data8);
+	ksz_pread8(dev, 5, REG_PORT_XMII_CTRL_1, &data8);
+	//printk("[KSZ9477] C ksz9477_rgmii_init[%d] REG_PORT_XMII_CTRL_1 data8=0x%X\n", 5, data8);
+	ksz_pwrite8(dev, 6, REG_PORT_XMII_CTRL_1, 0x18);
+	ksz_pread8(dev, 6, REG_PORT_XMII_CTRL_1, &data8);
+	//printk("[KSZ9477] C ksz9477_rgmii_init[%d] REG_PORT_XMII_CTRL_1 data8=0x%X\n", 6, data8);
+#endif	
+	//--------------------------------------
+#if 1
+	for (i=0; i<5; i++) {
+		ksz_pread16(dev, i, REG_PORT_PHY_CTRL, &data16);
+		//printk("[KSZ9477] 0 ksz9477_rgmii_init [%d]REG_PORT_PHY_CTRL(0xN100)=0x%04X \n", i, data16);
+		
+		ksz_pwrite16(dev, i, REG_PORT_PHY_CTRL, 0x1140);
+
+		ksz9477_port_mmd_read(dev, i, 0x2, 0x0, &data16);
+		printk("[ksz9477_rgmii_init] MMD LEDs Mode(Single/TriColor) (0x2, 0x0)=0x%04X \n", data16);
+		ksz9477_port_mmd_write(dev, i, 0x2, 0x0, 0x10);
+		
+	}
+#endif
+#if 0
+	for (i=0; i<7; i++) {
+		if (i==5) {
+			ksz9477_port_setup(dev, i, true);
+		} else {
+			ksz9477_port_setup(dev, i, false);
+		}
+	}
+#endif	
+
+	if (0) ksz9477_showinfo(dev);
+}
+
+void ksz9477_no_define_port_init(struct ksz_device *dev) {
+	u32 data32=0;
+	
+	if (!dev) {
+		printk("[ksz9477_no_define_port_init] dev is NULL ... \n");
+		return;
+	}
+#if 1
+	//Enable IBA Management
+	ksz_read32(dev, REG_SW_IBA__4, &data32);
+	//printk("[ksz9477_no_define_port_init] 1 REG_SW_IBA__4(0x%X)=0x%X \n", REG_SW_IBA__4, data32);
+	//data32 &= ~SW_IBA_ENABLE;
+	data32 |= SW_IBA_ENABLE;
+	ksz_write32(dev, REG_SW_IBA__4, data32);
+	ksz_read32(dev, REG_SW_IBA__4, &data32);
+	//printk("[ksz9477_no_define_port_init] 2 REG_SW_IBA__4(0x%X)=0x%X \n", REG_SW_IBA__4, data32);
+#endif
+
+	if (0) ksz9477_normal_init(dev);
+	if (1) {
+		ksz9477_eee_disable(dev);
+		ksz9477_rgmii_init(dev);
+		ksz9477_initsgmii(dev);
+		ksz9477_jumbo_frame_init(dev);
+	}
+	
+	//Monitor SGMII Auto neigotiation
+	INIT_DELAYED_WORK(&dev->sgmii_an, ksz9477_monitor_sgmii_an);
+	schedule_delayed_work(&dev->sgmii_an, 0);
+}
+
+void ksz9477_no_define_port_remove(struct ksz_device *dev) {
+	printk("[ksz9477_no_define_port_remove] Go ... \n");
+	cancel_delayed_work_sync(&dev->sgmii_an);
+}
+
 static int ksz9477_switch_init(struct ksz_device *dev)
 {
 	int i;
@@ -1559,17 +2098,20 @@ static int ksz9477_switch_init(struct ksz_device *dev)
 		}
 	}
 
+	//For No define port information in DTSI
+	ksz9477_no_define_port_init(dev);
 	/* no switch found */
 	if (!dev->port_cnt)
 		return -ENODEV;
+	//return -ENODEV;
 
 	dev->port_mask = (1 << dev->port_cnt) - 1;
 
 	dev->reg_mib_cnt = SWITCH_COUNTER_NUM;
 	dev->mib_cnt = TOTAL_SWITCH_COUNTER_NUM;
 
-	dev->ports = devm_kzalloc(dev->dev,
-				  dev->port_cnt * sizeof(struct ksz_port),
+	i = dev->port_cnt;
+	dev->ports = devm_kzalloc(dev->dev, sizeof(struct ksz_port) * i,
 				  GFP_KERNEL);
 	if (!dev->ports)
 		return -ENOMEM;
@@ -1586,7 +2128,6 @@ static int ksz9477_switch_init(struct ksz_device *dev)
 
 	/* set the real number of ports */
 	dev->ds->num_ports = dev->port_cnt;
-
 	return 0;
 }
 
diff --git a/drivers/net/dsa/microchip/ksz9477_reg.h b/drivers/net/dsa/microchip/ksz9477_reg.h
index 16939f29faa5..f469ea25b3e9 100644
--- a/drivers/net/dsa/microchip/ksz9477_reg.h
+++ b/drivers/net/dsa/microchip/ksz9477_reg.h
@@ -177,6 +177,15 @@
 
 #define REG_SW_MTU__2			0x0308
 
+#define SWITCH_PORT1			0x1400
+#define SWITCH_PORT2			0x2400
+#define SWITCH_PORT3			0x3400
+#define SWITCH_PORT4			0x4400
+#define SWITCH_PORT5			0x5400
+#define SWITCH_PORT6			0x6400
+
+#define PORTN_JUMBO_PACKET		BIT(0)
+
 #define REG_SW_ISP_TPID__2		0x030A
 
 #define REG_SW_HSR_TPID__2		0x030C
diff --git a/drivers/net/dsa/microchip/ksz9477_spi.c b/drivers/net/dsa/microchip/ksz9477_spi.c
index 43addeabfc25..8f44fc42831c 100644
--- a/drivers/net/dsa/microchip/ksz9477_spi.c
+++ b/drivers/net/dsa/microchip/ksz9477_spi.c
@@ -57,9 +57,10 @@ static int ksz9477_spi_probe(struct spi_device *spi)
 	ret = ksz9477_switch_register(dev);
 
 	/* Main DSA driver may not be started yet. */
+#if 0 //Pass No Port Setting
 	if (ret)
 		return ret;
-
+#endif
 	spi_set_drvdata(spi, dev);
 
 	return 0;
diff --git a/drivers/net/dsa/microchip/ksz_common.h b/drivers/net/dsa/microchip/ksz_common.h
index 1597c63988b4..0cb77bffbd14 100644
--- a/drivers/net/dsa/microchip/ksz_common.h
+++ b/drivers/net/dsa/microchip/ksz_common.h
@@ -82,6 +82,7 @@ struct ksz_device {
 
 	struct ksz_port *ports;
 	struct delayed_work mib_read;
+	struct delayed_work sgmii_an; //Monitor SGMII Auto neigotiation
 	unsigned long mib_read_interval;
 	u16 br_member;
 	u16 member;
@@ -171,6 +172,9 @@ int ksz_port_mdb_del(struct dsa_switch *ds, int port,
 		     const struct switchdev_obj_port_mdb *mdb);
 int ksz_enable_port(struct dsa_switch *ds, int port, struct phy_device *phy);
 
+void ksz9477_no_define_port_init(struct ksz_device *dev);
+void ksz9477_no_define_port_remove(struct ksz_device *dev);
+
 /* Common register access functions */
 
 static inline int ksz_read8(struct ksz_device *dev, u32 reg, u8 *val)
